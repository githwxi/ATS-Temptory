/*
**
** The C code is generated by ATS/Anairiats
** The compilation time is: 2013-8-30: 14h:38m
**
*/

/* include some .h files */
#ifndef _ATS_HEADER_NONE
#include "ats_config.h"
#include "ats_basics.h"
#include "ats_types.h"
#include "ats_exception.h"
#include "ats_memory.h"
#endif /* _ATS_HEADER_NONE */

/* include some .cats files */
#ifndef _ATS_PRELUDE_NONE
#include "prelude/CATS/basics.cats"
#include "prelude/CATS/bool.cats"
#include "prelude/CATS/char.cats"
#include "prelude/CATS/byte.cats"
#include "prelude/CATS/float.cats"
#include "prelude/CATS/integer.cats"
#include "prelude/CATS/integer_ptr.cats"
#include "prelude/CATS/integer_fixed.cats"
#include "prelude/CATS/sizetype.cats"
#include "prelude/CATS/pointer.cats"
#include "prelude/CATS/reference.cats"
#include "prelude/CATS/string.cats"
#include "prelude/CATS/lazy.cats"
#include "prelude/CATS/lazy_vt.cats"
#include "prelude/CATS/printf.cats"
#include "prelude/CATS/list.cats"
#include "prelude/CATS/option.cats"
#include "prelude/CATS/array.cats"
#include "prelude/CATS/matrix.cats"
#endif /* _ATS_PRELUDE_NONE */
/* prologues from statically loaded files */

/* external codes at top */
/* type definitions */
/* external typedefs */
/* external dynamic constructor declarations */
/* external dynamic constant declarations */
ATSextern_fun(ats_bool_type, atspre_gt_int_int) (ats_int_type, ats_int_type) ;
ATSextern_fun(ats_int_type, atspre_iadd) (ats_int_type, ats_int_type) ;
ATSextern_fun(ats_int_type, atspre_isub) (ats_int_type, ats_int_type) ;
ATSextern_fun(ats_bool_type, atspre_ilt) (ats_int_type, ats_int_type) ;
ATSextern_fun(ats_bool_type, atspre_igte) (ats_int_type, ats_int_type) ;
ATSextern_fun(ats_void_type, atspre_prerr_string) (ats_ptr_type) ;
ATSextern_fun(ats_bool_type, chunklst_is_cons) (ats_ptr_type) ;
ATSextern_fun(ats_ptr_type, botsegtbllst_get) (ats_ptr_type, ats_int_type) ;
ATSextern_fun(ats_ptr_type, markstackpagelst_nil) () ;
ATSextern_fun(ats_bool_type, markstackpagelst_is_nil) (ats_ptr_type) ;
ATSextern_fun(ats_bool_type, markstackpagelst_is_cons) (ats_ptr_type) ;
ATSextern_fun(ats_ptr_type, markstackpagelst_next_get) (ats_ptr_type) ;
ATSextern_fun(ats_ptr_type, markstackpagelst_prev_get) (ats_ptr_type) ;
ATSextern_fun(ats_void_type, markstackpagelst_entry_get) (ats_ptr_type, ats_int_type, ats_ref_type, ats_ref_type) ;
ATSextern_fun(ats_void_type, markstackpagelst_entry_set) (ats_ptr_type, ats_int_type, ats_ptr_type, ats_int_type) ;
ATSextern_fun(ats_void_type, gc_overflow_mark_the_topsegtbl) () ;
ATSextern_fun(ats_void_type, gc_mark_the_stack) () ;
ATSextern_fun(ats_void_type, gc_mark_the_globalentrylst) () ;
ATSextern_fun(ats_void_type, gc_mark_the_manmemlst) () ;
ATSextern_fun(ats_void_type, gc_overflow_mark_chunk) (ats_ptr_type) ;
ATSextern_fun(ats_void_type, gc_overflow_mark_botsegtbl) (ats_ptr_type) ;
ATSextern_fun(ats_int_type, the_markstack_overflow_get) () ;
ATSextern_fun(ats_void_type, the_markstack_overflow_set) () ;
ATSextern_fun(ats_void_type, the_markstack_overflow_clear) () ;
ATSextern_val(ats_int_type, the_markstackpagecnt) ;
ATSextern_val(ats_ptr_type, the_markstackpagelst_fst) ;
ATSextern_val(ats_ptr_type, the_markstackpagelst_cur) ;
ATSextern_val(ats_int_type, the_markstackposition) ;

/* external dynamic terminating constant declarations */
#ifdef _ATS_PROOFCHECK
#endif /* _ATS_PROOFCHECK */

/* assuming abstract types */
/* sum constructor declarations */
/* exn constructor declarations */
/* global dynamic (non-functional) constant declarations */
ATSglobal(ats_int_type, the_markstackpagecnt) ;
ATSglobal(ats_ptr_type, the_markstackpagelst_fst) ;
ATSglobal(ats_ptr_type, the_markstackpagelst_cur) ;
ATSglobal(ats_int_type, the_markstackposition) ;

/* internal function declarations */
static
ats_int_type gcats1_marking_aux_1 (ats_ptr_type arg0, ats_int_type arg1) ;
static
ats_void_type gcats1_marking_loop_5 (ats_ptr_type arg0, ats_int_type arg1) ;
static
ats_void_type gcats1_marking_loop_7 (ats_int_type arg0) ;

/* partial value template declarations */
/* static temporary variable declarations */
ATSstatic (ats_ptr_type, gcats1_marking_statmp43) ;

/* external value variable declarations */

/* function implementations */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 1781(line=56, offs=7) -- 1958(line=60, offs=8)
*/
ATSstaticdec()
ats_int_type
gcats1_marking_aux_1 (ats_ptr_type arg0, ats_int_type arg1) {
/* local vardec */
ATSlocal (ats_int_type, tmp1) ;
ATSlocal (ats_bool_type, tmp2) ;
ATSlocal (ats_ptr_type, tmp3) ;
ATSlocal (ats_int_type, tmp4) ;

__ats_lab_gcats1_marking_aux_1:
#line 58 "gcats1_marking.dats"
tmp2 = markstackpagelst_is_nil (arg0) ;
#line 58 "gcats1_marking.dats"
if (tmp2) {
#line 58 "gcats1_marking.dats"
tmp1 = arg1 ;
} else {
#line 59 "gcats1_marking.dats"
tmp3 = markstackpagelst_next_get (arg0) ;
#line 59 "gcats1_marking.dats"
tmp4 = atspre_iadd (arg1, 1) ;
#line 59 "gcats1_marking.dats"
arg0 = tmp3 ;
#line 59 "gcats1_marking.dats"
arg1 = tmp4 ;
#line 59 "gcats1_marking.dats"
goto __ats_lab_gcats1_marking_aux_1 ; // tail call
} /* end of [if] */
return (tmp1) ;
} /* end of [gcats1_marking_aux_1] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 1762(line=55, offs=35) -- 1996(line=63, offs=4)
*/
ATSglobaldec()
ats_int_type
markstackpagelst_length (ats_ptr_type arg0) {
/* local vardec */
ATSlocal (ats_int_type, tmp0) ;

__ats_lab_markstackpagelst_length:
#line 62 "gcats1_marking.dats"
tmp0 = gcats1_marking_aux_1 (arg0, 0) ;
return (tmp0) ;
} /* end of [markstackpagelst_length] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 2079(line=67, offs=25) -- 2677(line=87, offs=4)
*/
ATSglobaldec()
ats_int_type
markstack_pop (ats_ref_type arg0, ats_ref_type arg1, ats_ref_type arg2, ats_ref_type arg3) {
/* local vardec */
ATSlocal (ats_int_type, tmp5) ;
ATSlocal (ats_int_type, tmp6) ;
ATSlocal (ats_bool_type, tmp7) ;
// ATSlocal_void (tmp8) ;
ATSlocal (ats_ptr_type, tmp9) ;
ATSlocal (ats_bool_type, tmp10) ;
ATSlocal (ats_int_type, tmp11) ;
// ATSlocal_void (tmp12) ;

__ats_lab_markstack_pop:
#line 68 "gcats1_marking.dats"
tmp6 = atspre_isub (ats_ptrget_mac(ats_int_type, arg1), 1) ;
#line 70 "gcats1_marking.dats"
tmp7 = atspre_igte (tmp6, 0) ;
#line 70 "gcats1_marking.dats"
if (tmp7) {
#line 71 "gcats1_marking.dats"
/* tmp8 = */ markstackpagelst_entry_get (ats_ptrget_mac(ats_ptr_type, arg0), tmp6, arg2, arg3) ;
#line 73 "gcats1_marking.dats"
ats_ptrget_mac(ats_int_type, arg1) = tmp6 ;
#line 73 "gcats1_marking.dats"
tmp5 = 0 ;
} else {
#line 75 "gcats1_marking.dats"
tmp9 = markstackpagelst_prev_get (ats_ptrget_mac(ats_ptr_type, arg0)) ;
#line 77 "gcats1_marking.dats"
tmp10 = markstackpagelst_is_cons (tmp9) ;
#line 77 "gcats1_marking.dats"
if (tmp10) {
#line 78 "gcats1_marking.dats"
ats_ptrget_mac(ats_ptr_type, arg0) = tmp9 ;
#line 79 "gcats1_marking.dats"
tmp11 = atspre_isub (4000, 1) ;
#line 80 "gcats1_marking.dats"
/* tmp12 = */ markstackpagelst_entry_get (ats_ptrget_mac(ats_ptr_type, arg0), tmp11, arg2, arg3) ;
#line 82 "gcats1_marking.dats"
ats_ptrget_mac(ats_int_type, arg1) = tmp11 ;
#line 82 "gcats1_marking.dats"
tmp5 = 0 ;
} else {
#line 84 "gcats1_marking.dats"
ats_ptrget_mac(ats_ptr_type, arg2) = atspre_null_ptr ;
#line 84 "gcats1_marking.dats"
ats_ptrget_mac(ats_int_type, arg3) = 0 ;
#line 84 "gcats1_marking.dats"
tmp5 = 1 ;
} /* end of [if] */
} /* end of [if] */
return (tmp5) ;
} /* end of [markstack_pop] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 2751(line=91, offs=26) -- 3336(line=112, offs=4)
*/
ATSglobaldec()
ats_int_type
markstack_push (ats_ref_type arg0, ats_ref_type arg1, ats_ptr_type arg2, ats_int_type arg3) {
/* local vardec */
ATSlocal (ats_int_type, tmp13) ;
ATSlocal (ats_int_type, tmp14) ;
ATSlocal (ats_bool_type, tmp15) ;
// ATSlocal_void (tmp16) ;
ATSlocal (ats_int_type, tmp17) ;
ATSlocal (ats_bool_type, tmp19) ;
ATSlocal (ats_ptr_type, tmp20) ;
ATSlocal (ats_bool_type, tmp21) ;

__ats_lab_markstack_push:
#line 92 "gcats1_marking.dats"
tmp14 = ats_ptrget_mac(ats_int_type, arg1) ;
#line 94 "gcats1_marking.dats"
tmp15 = atspre_ilt (tmp14, 4000) ;
#line 94 "gcats1_marking.dats"
if (tmp15) {
#line 95 "gcats1_marking.dats"
/* tmp16 = */ markstackpagelst_entry_set (ats_ptrget_mac(ats_ptr_type, arg0), tmp14, arg2, arg3) ;
#line 96 "gcats1_marking.dats"
tmp17 = atspre_iadd (tmp14, 1) ;
#line 97 "gcats1_marking.dats"
tmp19 = atspre_ilt (tmp17, 4000) ;
#line 97 "gcats1_marking.dats"
if (tmp19) {
#line 97 "gcats1_marking.dats"
ats_ptrget_mac(ats_int_type, arg1) = tmp17 ;
} else {
#line 99 "gcats1_marking.dats"
tmp20 = markstackpagelst_next_get (ats_ptrget_mac(ats_ptr_type, arg0)) ;
#line 101 "gcats1_marking.dats"
tmp21 = markstackpagelst_is_cons (tmp20) ;
#line 101 "gcats1_marking.dats"
if (tmp21) {
#line 102 "gcats1_marking.dats"
ats_ptrget_mac(ats_ptr_type, arg0) = tmp20 ;
#line 102 "gcats1_marking.dats"
ats_ptrget_mac(ats_int_type, arg1) = 0 ;
} else {
#line 104 "gcats1_marking.dats"
ats_ptrget_mac(ats_int_type, arg1) = 4000 ;
} /* end of [if] */
} /* end of [if] */
#line 108 "gcats1_marking.dats"
tmp13 = 0 ;
} else {
#line 110 "gcats1_marking.dats"
tmp13 = 1 ;
} /* end of [if] */
return (tmp13) ;
} /* end of [markstack_push] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 3678(line=124, offs=7) -- 3982(line=132, offs=8)
*/
ATSstaticdec()
ats_void_type
gcats1_marking_loop_5 (ats_ptr_type arg0, ats_int_type arg1) {
/* local vardec */
// ATSlocal_void (tmp23) ;
ATSlocal (ats_bool_type, tmp24) ;
ATSlocal (ats_ptr_type, tmp25) ;
// ATSlocal_void (tmp26) ;
ATSlocal (ats_bool_type, tmp27) ;
ATSlocal (ats_int_type, tmp28) ;

__ats_lab_gcats1_marking_loop_5:
#line 126 "gcats1_marking.dats"
tmp24 = atspre_ilt (arg1, 1024) ;
#line 126 "gcats1_marking.dats"
if (tmp24) {
#line 127 "gcats1_marking.dats"
tmp25 = botsegtbllst_get (arg0, arg1) ;
#line 128 "gcats1_marking.dats"
tmp27 = chunklst_is_cons (tmp25) ;
#line 128 "gcats1_marking.dats"
if (tmp27) {
#line 128 "gcats1_marking.dats"
/* tmp26 = */ gc_overflow_mark_chunk (tmp25) ;
} else {
/* empty */
} /* end of [if] */
#line 131 "gcats1_marking.dats"
tmp28 = atspre_iadd (arg1, 1) ;
#line 131 "gcats1_marking.dats"
arg0 = arg0 ;
#line 131 "gcats1_marking.dats"
arg1 = tmp28 ;
#line 131 "gcats1_marking.dats"
goto __ats_lab_gcats1_marking_loop_5 ; // tail call
} else {
/* empty */
} /* end of [if] */
return /* (tmp23) */ ;
} /* end of [gcats1_marking_loop_5] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 3611(line=122, offs=38) -- 3999(line=133, offs=2)
*/
ATSglobaldec()
ats_void_type
gc_overflow_mark_botsegtbl (ats_ptr_type arg0) {
/* local vardec */
// ATSlocal_void (tmp22) ;

__ats_lab_gc_overflow_mark_botsegtbl:
#line 122 "gcats1_marking.dats"
/* tmp22 = */ gcats1_marking_loop_5 (arg0, 0) ;
return /* (tmp22) */ ;
} /* end of [gc_overflow_mark_botsegtbl] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 4796(line=162, offs=9) -- 5062(line=169, offs=10)
*/
ATSstaticdec()
ats_void_type
gcats1_marking_loop_7 (ats_int_type arg0) {
/* local vardec */
// ATSlocal_void (tmp37) ;
ATSlocal (ats_bool_type, tmp38) ;
// ATSlocal_void (tmp39) ;
// ATSlocal_void (tmp40) ;
ATSlocal (ats_int_type, tmp41) ;

__ats_lab_gcats1_marking_loop_7:
#line 163 "gcats1_marking.dats"
tmp38 = atspre_gt_int_int (arg0, 0) ;
#line 163 "gcats1_marking.dats"
if (tmp38) {
#line 164 "gcats1_marking.dats"
/* tmp39 = */ the_markstack_overflow_clear () ;
#line 165 "gcats1_marking.dats"
/* tmp40 = */ gc_overflow_mark_the_topsegtbl () ;
#line 166 "gcats1_marking.dats"
tmp41 = the_markstack_overflow_get () ;
#line 168 "gcats1_marking.dats"
arg0 = tmp41 ;
#line 168 "gcats1_marking.dats"
goto __ats_lab_gcats1_marking_loop_7 ; // tail call
} else {
/* empty */
} /* end of [if] */
return /* (tmp37) */ ;
} /* end of [gcats1_marking_loop_7] */

/*
// /home/hwxi/research/Anairiats/ccomp/runtime/GCATS1/gcats1_marking.dats: 4329(line=146, offs=23) -- 5118(line=173, offs=4)
*/
ATSglobaldec()
ats_int_type
gc_mark_all () {
/* local vardec */
ATSlocal (ats_int_type, tmp29) ;
// ATSlocal_void (tmp30) ;
// ATSlocal_void (tmp31) ;
// ATSlocal_void (tmp32) ;
// ATSlocal_void (tmp33) ;
ATSlocal (ats_int_type, tmp34) ;
// ATSlocal_void (tmp35) ;
ATSlocal (ats_bool_type, tmp36) ;
// ATSlocal_void (tmp42) ;

__ats_lab_gc_mark_all:
#line 147 "gcats1_marking.dats"
/* tmp30 = */ gc_mark_the_globalentrylst () ;
#line 148 "gcats1_marking.dats"
/* tmp31 = */ gc_mark_the_manmemlst () ;
#line 152 "gcats1_marking.dats"
/* tmp32 = */ the_markstack_overflow_clear () ;
#line 153 "gcats1_marking.dats"
/* tmp33 = */ gc_mark_the_stack () ;
#line 154 "gcats1_marking.dats"
tmp34 = the_markstack_overflow_get () ;
#line 157 "gcats1_marking.dats"
tmp36 = atspre_gt_int_int (tmp34, 0) ;
#line 157 "gcats1_marking.dats"
if (tmp36) {
#line 158 "gcats1_marking.dats"
/* tmp35 = */ atspre_prerr_string (ATSstrcst("GC: [gc_mark_all]: mark stack overflow happened!\n")) ;
} else {
/* empty */
} /* end of [if] */
#line 161 "gcats1_marking.dats"
/* tmp42 = */ gcats1_marking_loop_7 (tmp34) ;
#line 172 "gcats1_marking.dats"
tmp29 = tmp34 ;
return (tmp29) ;
} /* end of [gc_mark_all] */

/* static load function */

extern ats_void_type ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_2esats__staload (void) ;

ats_void_type
ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__staload () {
static int ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__staload_flag = 0 ;
if (ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__staload_flag) return ;
ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__staload_flag = 1 ;

ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_2esats__staload () ;

return ;
} /* staload function */

/* dynamic load function */

// dynload flag declaration
extern ats_int_type ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__dynload_flag ;

ats_void_type
ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__dynload () {
ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__dynload_flag = 1 ;
ATS_2d0_2e2_2e10_2ccomp_2runtime_2GCATS1_2gcats1_marking_2edats__staload () ;

#ifdef _ATS_PROOFCHECK
#endif /* _ATS_PROOFCHECK */

/* marking static variables for GC */
ATS_GC_MARKROOT(&gcats1_marking_statmp43, sizeof(ats_ptr_type)) ;

/* marking external values for GC */

/* code for dynamic loading */
#line 195 "gcats1_marking.dats"
ATS_GC_MARKROOT(&the_markstackpagecnt, sizeof(ats_int_type)) ;
the_markstackpagecnt = 0 ;
#line 196 "gcats1_marking.dats"
gcats1_marking_statmp43 = markstackpagelst_nil () ;
#line 196 "gcats1_marking.dats"
ATS_GC_MARKROOT(&the_markstackpagelst_fst, sizeof(ats_ptr_type)) ;
the_markstackpagelst_fst = gcats1_marking_statmp43 ;
#line 197 "gcats1_marking.dats"
ATS_GC_MARKROOT(&the_markstackpagelst_cur, sizeof(ats_ptr_type)) ;
the_markstackpagelst_cur = the_markstackpagelst_fst ;
#line 198 "gcats1_marking.dats"
ATS_GC_MARKROOT(&the_markstackposition, sizeof(ats_int_type)) ;
the_markstackposition = 0 ;
return ;
} /* end of [dynload function] */

/* external codes at mid */
/* external codes at bot */
#line 204 "gcats1_marking.dats"


extern ats_ptr_type the_markstackpagelst_fst ;

ats_void_type the_markstack_extend (ats_int_type n) {
  int i ; markstackpagelst p0, p ;
  p0 = the_markstackpagelst_fst ;

  if (the_markstackposition != 0) {
    fprintf (
      stderr
    , "GC: Fatal Error: the_markstack_extend: the_markstackposition = %i.\n"
    , the_markstackposition
    ) ;
    exit (1) ;
  } // end of [if]

  for (i = 0; i < n; i += 1) {
/*
    fprintf (stderr, "the_markstack_extend: i = %i\n", i) ;
*/
    p = (markstackpagelst)malloc (sizeof(markstackpage)) ; if (!p) {
      fprintf (
        stderr, "GC Fatal Error: [the_markstack_extend]: malloc failed!\n"
      ) ;
      exit (1) ;
    } // end of [if]

    if (p0 != NULL) p0->prev = p ; p->next = p0 ; p->prev = NULL ; p0 = p ;
  } // end of [while]

  if (n > 0) the_markstackpagecnt += n ;
  the_markstackpagelst_fst = the_markstackpagelst_cur = p0 ;

/*
  if (the_markstackpagecnt != markstackpagelst_length (p0)) {
    fprintf (
      stderr
    , "GC: Fatal Error: the_markstack_extend: the_markstackpagecnt = %i.\n"
    , the_markstackpagecnt
    ) ;
    exit (1) ;
  } // end of [if]
*/

  return ;
} /* end of [the_markstack_extend] */

/* ****** ****** */

extern ats_ptr_type gc_ptr_is_valid (ats_ptr_type, ats_ref_type) ;

ats_void_type gc_mark_ptr (ats_ptr_type ptr) {
  chunklst chks ;
  int ofs ; int itemwsz ;
  byte *markbits ;
  int i ; freeitmlst *ptr_i ;
  freeitmlst ptr_cand ;
  int overflow ;

/*
  fprintf (stderr, "gc_mark_ptr: first: ptr = %p(%i)\n", ptr, ptr) ;
*/
  chks = (chunklst)gc_ptr_is_valid (ptr, &ofs) ;
/*
  fprintf (stderr, "gc_mark_ptr: chks = %p\n", chks) ;
*/

  if (!chks) return ; // [ptr] is invalid
  markbits = chks->markbits ;
  if (MARK_GET(markbits, ofs)) return ; // already marked
  MARK_SET(markbits, ofs) ; chks->markcnt += 1 ;

  itemwsz = chks->itemwsz ;

  while (ptr) { // ptr != NULL
/*
    fprintf (stderr, "gc_mark_ptr: ptr = %p(%i)\n", ptr, ptr) ;
    fprintf (stderr, "gc_mark_ptr: itemwsz = %i\n", itemwsz);
*/
    if (itemwsz > MARKSTACK_CUTOFF) {
      overflow = the_markstack_push (
        (freeitmlst*)ptr + MARKSTACK_CUTOFF, itemwsz - MARKSTACK_CUTOFF
      ) ;
      if (overflow) the_markstack_overflow_set () ;
      itemwsz = MARKSTACK_CUTOFF ;
    } // end of [if]
    
    // push all the valid pointers onto the markstack except the last one
    ptr_i = (freeitmlst*)ptr ;
    for (i = 0; i < itemwsz - 1; i += 1, ptr_i += 1) {
      ptr_cand = *ptr_i ;
/*
      fprintf (stderr, "gc_mark_ptr: ptr_i = %p(%i)\n", ptr_i, ptr_i) ;
      fprintf (stderr, "gc_mark_ptr: ptr_cand = %p(%i)\n", ptr_cand, ptr_cand) ;
*/
      chks = (chunklst)gc_ptr_is_valid (ptr_cand, &ofs) ;
      if (!chks) continue ; // [ptr_cand] is invalid
      markbits = chks->markbits ;
      if (MARK_GET(markbits, ofs)) continue ; // already marked
      MARK_SET(markbits, ofs) ; chks->markcnt += 1 ;
      overflow = the_markstack_push (ptr_cand, chks->itemwsz) ;
      if (overflow) the_markstack_overflow_set () ;
    } // end of [for]

    ptr_cand = *ptr_i ;
/*
    fprintf (stderr, "gc_mark_ptr: ptr_i = %p(%i)\n", ptr_i, ptr_i) ;
    fprintf (stderr, "gc_mark_ptr: ptr_cand = %p(%i)\n", ptr_cand, ptr_cand) ;
*/
    chks = (chunklst)gc_ptr_is_valid (ptr_cand, &ofs) ;
    if (!chks) { // [ptr_cand] is invalid
      the_markstack_pop (&ptr, &itemwsz) ; continue ;
    } // end of [if]
    markbits = chks->markbits ;
    if (MARK_GET(markbits, ofs)) { // [ptr_cand] is marked
      the_markstack_pop (&ptr, &itemwsz) ; continue ;
    }
    MARK_SET(markbits, ofs) ; chks->markcnt += 1 ;
    ptr = ptr_cand ; itemwsz = chks->itemwsz ;
  } // end of [while]
} /* end of [gc_mark_ptr] */

#line 331 "gcats1_marking.dats"


// [chks] must not be NULL!
ats_void_type gc_overflow_mark_chunk (ats_ptr_type chks) {
  int i, j ; freeitmlst *pi, *pij ;
  int itemwsz, itemtot ; byte *markbits ;

  itemwsz = chunklst_itemwsz_get (chks) ;
  itemtot = chunklst_itemtot_get (chks) ;
  markbits = chunklst_markbits_get (chks) ;

  pi = (freeitmlst*)chunklst_data_get (chks) ;
  for (i = 0; i < itemtot; i += 1, pi += itemwsz) {
    if (MARK_GET(markbits, i)) {
      for (j = 0, pij = pi; j < itemwsz; j += 1, pij += 1) {
        gc_mark_ptr (pij) ;
      } // end of [for]
    } // end of [if]
  } // end of [for]
} /* end of [gc_overflow_mark_chunk] */

/* ****** ****** */

#if (__WORDSIZE == 32)

ats_void_type gc_overflow_mark_the_topsegtbl () {
  int i ; botsegtbllst tbls ;
  for (i = 0; i < TOPSEG_TABLESIZE; i += 1) {
    tbls = the_topsegtbl[i] ;
    if (tbls) gc_overflow_mark_botsegtbl (tbls) ;
  } // end of [for]
  return ;
} /* end of [gc_overflow_mark_the_topsegtbl] */

#endif // end of [__WORDSIZE == 32]

#if (__WORDSIZE == 64)

ats_void_type gc_overflow_mark_the_topsegtbl () {
  int i ; botsegtbllst tbls ;
  for (i = 0; i < TOPSEG_HASHTABLESIZE; i += 1) {
    tbls = the_topsegtbl[i] ;
    while (tbls) { // terminating: obvious
      gc_overflow_mark_botsegtbl (tbls) ; tbls = tbls->hash_next ;
    } // end of [while]
  } // end of [for]
  return ;
} /* end of [gc_overflow_mark_the_topsegtbl] */

#endif // end of [__WORDSIZE == 64]

#line 386 "gcats1_marking.dats"


extern ats_ptr_type the_globalentrylst ;
extern ats_void_type gc_mark_globalentrylst (ats_ptr_type ents) ;

ats_void_type gc_mark_the_globalentrylst () {
  gc_mark_globalentrylst (the_globalentrylst) ; return ;
}

extern ats_ptr_type gc_stack_beg_get () ;

ats_void_type gc_mark_the_stack () {
  intptr_t dir ; // make sure that [dir] is word-aligned!
  freeitmlst *_fr, *_to ;

  dir = gc_stack_dir_get () ;

  if (dir > 0) {
    _fr = gc_stack_beg_get () ; _to = (freeitmlst*)(&dir) - 1 ;
  } else {
    _to = gc_stack_beg_get () ; _fr = (freeitmlst*)(&dir) + 1 ;
  } // end of [if]
/*
  fprintf (stderr, "gc_mark_the_stack: _fr = %p(%u)\n", _fr, _fr) ;
  fprintf (stderr, "gc_mark_the_stack: _to = %p(%u)\n", _to, _to) ;
  fprintf (stderr, "gc_mark_the_stack: _to - _fr = %i\n", _to - _fr) ;
*/
  while (_fr <= _to) {
    gc_mark_ptr (*_fr) ; _fr += 1 ; // termination: obvious
  } // end of [while]

  return ;
} /* end of [gc_mark_the_stack] */



/* ****** ****** */

/* end of [gcats1_marking_dats.c] */
